<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Cox Proportional Hazard Models</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.21/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Cox Proportional Hazard Models
]
.subtitle[
## Survival Analysis
]

---








#### Exercises 

1. Write down the equation of the **Cox proportional hazards model** in which the hazard function depends on duration `\(t\)` and a vector of covariates `\(z\)`. 
You should define all the other terms that you use.

2. Explain why the Cox model is sometimes described as ***semi-parametric***.

(Exercise 3 to follow)
---


#### Exercise 1

The Cox proportional hazards model is a widely used statistical model for analyzing survival data. It models the hazard function, which is the instantaneous risk of an event (such as death or failure) at a specific time, given that the event has not yet occurred.

The equation of the Cox proportional hazards model is:

```
h(t | z) = h_0(t) * exp(β^T z)
```

where:

* `h(t | z)` is the hazard function at time `t` for an individual with covariate vector `z`.
* `h_0(t)` is the baseline hazard function, which is the hazard function for an individual with all covariates equal to zero.
* `β` is a vector of regression coefficients that quantify the effect of the covariates on the hazard function.
* `z` is a vector of covariates.

The Cox model assumes that the hazard ratio, which is the ratio of the hazard functions for two individuals with different covariate vectors, is constant over time. This is known as the ***proportional hazards assumption***.

---

#### Exercise 2

The Cox model is sometimes described as **semi-parametric** because it makes parametric assumptions about the relationship between the covariates and the hazard function (through the regression coefficients), but it makes no parametric assumptions about the baseline hazard function. This flexibility in modeling the baseline hazard function makes the Cox model a powerful tool for analyzing survival data.

---

#### Exercise 3

* A Cox proportional hazards model was estimated to assess the effect on survival of a
person's sex and their self-esteem (measured on a three-point scale as ***low***, ***medium*** or ***high*** ). 

* The baseline category was males with low self-esteem.

* Write down the equation of the model, using algebraic symbols to represent variables
and parameters and defining all the symbols that you use.

---

#### Categorical Variables

* ***Sex***: 2 levels (i.e. male or female, with male as baseline)

* ***Self Esteem***: 3 levels (i.e. low, medium or high, with low as baseline)

* These variables are specified in the model using binary variables for the non-baseline levels.
---

The Cox proportional hazards model for this scenario can be written as:

```
h(t|sex,slf_estm) = h_0(t) exp(β_1 sex_f + β_2 slf_estm_M + β_3 slf_estm_H)
```

where:

* `h(t | sex, slf_estm)` is the hazard function at time `t` for an individual with given `sex` and `slf_estm`.

* `h_0(t)` is the baseline hazard function (for males with low self-esteem).

* `β_1`, `β_2`, and `β_3` are the regression coefficients for `sex` and the different levels of `slf_estm`.

* `sex_f` is a binary indicator variable equal to 1 if the individual is female and 0 otherwise.

* `slf_estm_M` and `slf_estm_H` are binary indicator variables equal to 1 if the individual's self-esteem is medium or high, respectively, and 0 otherwise.

---

* This equation models the hazard function as a multiplicative function of the baseline hazard and the exponentiated linear combination of the covariates. 

* The coefficients `β_1`, `β_2`, and `β_3` quantify the effect of `sex` and `slf_estm` on the hazard function, relative to the baseline group of males with low self-esteem.

---


---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
